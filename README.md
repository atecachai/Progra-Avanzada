# Progra-Avanzada
## Tarea 1
### Preguntas Teoricas:
1. ¿Que es un paradigma de programación?    
    Es una manera de resolver un problema en particular, usando herramientas de programación. Es decir, son los algoritmos y patrones que usamos para resolver problemas de programación. Se pueden identificar dos grandes paradigmas: (1). Programación Imperativa y (2). Programación Declarativa. El primero es el mas antiguo y se basa en una secuencia de instrucciones que van actualizando un programa. Dentro de este se encuentra la programación orientada a objetos. El segundo describe las cosas que se deben hacer las cosas, en vez de como hacerlas.
2. ¿En qué se basa la programación orientada a objetos?
    En poder modelar el mundo real. Para esto crea objetos y les da formas de interactuar entre ellos en distintos estados. Esto se ve reflejado en un programa el cual esta compuesto por clases, sus atributos, y maneras de interactuar con otros objetos y el mismo, que son los metodos. Para este caso, la clase sirve de plantilla, y el objeto es una instancia de esta plantilla. A esta instancia se le pueden dar distintos atributos asi como metodos para interactuar con otras instancias.
3. ¿Cuál es la diferencia entre recursividad e iteración, y cómo se relaciona esto con la notación
big 𝑂?
    La iteración se refiere a repetir una accion o una operación un numero determinado de veces. La recursividad, en particular en programacion, se refiere a llevar a cabo una operacion pero llamandose o invocandose a si misma. Es decir, una funcion que se llama a si misma para resolver un problema. De manera general se puede entender que la recursividad busca generar subproblemas mas pequeños para irlos solucionando hasta llegar a un caso base, mientras que la iteracion simplemente resuelve problemas cierta cantidad de veces. Cabe mencionar que la iteracion es un caso especial de recursividad. Relacionandolo con la nocion de big O, en ciertas situaciones se podria dar que un metodo es mejor que el otro en desmpeño, como por ejemplo los numeros de Fibonacci, donde la metodologia recursiva es O(2^n), y una iterativa (con memoria de resultados) es O(n). Con esto se quiere transmitir que dependiendo del problema, un metodo recursivo puede ser mas eficiente que uno iterativo, o viceversa, asi como que ambos puedan ser igual de eficientes.
4. Explicar la diferencia de rendimiento entre 𝑂(1) y 𝑂(𝑛)
    El O(1) se refiere a una complejidad constante o tiempo de ejecucion fijo, que no cambia a medida que aumente la entrada por ejemplo, a realizar una accion especifica, como darle dos numeros a una funcion y que los sume. Por el otro lado, O(n) va relacionado con un crecimiento lineal de la complejidad o tiempo de ejecución en relacion con la entrada, como iterar sobre una lista de n elementos. Esto signfica que para una entrada muy grande, O(1) tendria mejor rendimiento que para O(n), ya que se demoraria lo mismo para cualquier entrada, y por ende, menos que para O(n). En casos de entradas no tan altas esta diferencia podria ser despreciable. 
5. ¿Cómo se calcula el orden en un programa que funciona por etapas?
    Se debe analizar cada etapa, y determinar que notacion le corresponde. Luego se pueden "sumar" estas, y finalmente la más lenta o la menos eficiente es la que domina, respetando la jerarquia que existe entrada cada uno de los niveles. Por ejemplo, si se tiene un programa que resuelve una multiplicación y arroja un resultado, que luego se usa para iterar en una lista de n elementos, se parte con O(1), pero se termina con O(n), por lo que el orden seria O(n). Esto ya que la complejidad seria O(n)+O(1), pero O(n) es la complejidad dominante.
6. ¿Cómo se puede determinar la complejidad temporal de un algoritmo recursivo?
    Se debe identificar la recurrencia, y ver si es afectada por valores externos, ademas de ver que se hace con la entrada al ser llamada. Viendo la complejidad temporal del factor externo y analizando que se realiza con la entrada (se duplica, resta, se le aplica log, etc), se puede dar una idea de como evoluciona la entrada a medida que el algoritmo corre. Con esto y observando el codigo para entender a grandes rasgos que se quiere hacerm, se puede determinar la complejidad de un algoritmo recursivo.