# Progra-Avanzada
## Tarea 1
### Preguntas Teoricas:
1. ¿Que es un paradigma de programación?    
    Es una manera de resolver un problema en particular usando herramientas de programación. Es decir, son los algoritmos y patrones que utilizamos para resolver problemas de programación. Se pueden identificar dos grandes paradigmas: (1) Programación Imperativa y (2) Programación Declarativa. El primero es el más antiguo y se basa en una secuencia de instrucciones que van actualizando un programa. Dentro de este se encuentra la programación orientada a objetos. El segundo describe qué se debe hacer, en lugar de cómo hacerlo.
2. ¿En qué se basa la programación orientada a objetos?
    Para poder modelar el mundo real, se crean objetos y se les da formas de interactuar entre ellos en distintos estados. Esto se ve reflejado en un programa que está compuesto por clases, sus atributos y las maneras de interactuar con otros objetos y consigo mismo, que son los métodos. En este caso, la clase sirve de plantilla, y el objeto es una instancia de dicha plantilla. A esta instancia se le pueden asignar distintos atributos, así como métodos para interactuar con otras instancias.
3. ¿Cuál es la diferencia entre recursividad e iteración, y cómo se relaciona esto con la notación
big 𝑂?
    La iteración se refiere a repetir una acción o una operación un número determinado de veces. La recursividad, en particular en programación, se refiere a llevar a cabo una operación invocándose a sí misma. Es decir, una función que se llama a sí misma para resolver un problema. De manera general, se puede entender que la recursividad busca generar subproblemas más pequeños para ir solucionándolos hasta llegar a un caso base, mientras que la iteración simplemente resuelve problemas cierta cantidad de veces. Cabe mencionar que la iteración es un caso especial de recursividad. Relacionándolo con la noción de Big O, en ciertas situaciones podría darse que un método es mejor que el otro en desempeño. Por ejemplo, en el cálculo de los números de Fibonacci, la metodología recursiva es O(2^n), mientras que una iterativa (con memoria de resultados) es O(n). Con esto se quiere transmitir que, dependiendo del problema, un método recursivo puede ser más eficiente que uno iterativo, o viceversa, así como que ambos puedan ser igual de eficientes.
4. Explicar la diferencia de rendimiento entre 𝑂(1) y 𝑂(𝑛)
    El O(1) se refiere a una complejidad constante o tiempo de ejecución fijo, que no cambia a medida que aumenta la entrada. Un ejemplo sería realizar una acción específica, como darle dos números a una función y que los sume. Por otro lado, O(n) está relacionado con un crecimiento lineal de la complejidad o tiempo de ejecución en relación con la entrada, como iterar sobre una lista de n elementos. Esto significa que, para una entrada muy grande, O(1) tendría mejor rendimiento que O(n), ya que se demoraría lo mismo para cualquier entrada y, por ende, menos que O(n). En casos de entradas no tan grandes, esta diferencia podría ser despreciable. 
5. ¿Cómo se calcula el orden en un programa que funciona por etapas?
    Se debe analizar cada etapa y determinar qué notación le corresponde. Luego, se pueden "sumar" estas, y finalmente la más lenta o la menos eficiente es la que domina, respetando la jerarquía que existe entre cada uno de los niveles. Por ejemplo, si se tiene un programa que resuelve una multiplicación y arroja un resultado, que luego se usa para iterar en una lista de n elementos, se parte con O(1), pero se termina con O(n), por lo que el orden sería O(n). Esto se debe a que la complejidad sería O(n) + O(1), pero O(n) es la complejidad dominante.
6. ¿Cómo se puede determinar la complejidad temporal de un algoritmo recursivo?
    Se debe identificar la recurrencia y ver si está afectada por valores externos, además de analizar qué se hace con la entrada al ser llamada. Viendo la complejidad temporal del factor externo y analizando qué se realiza con la entrada (si se duplica, resta, se le aplica log, etc.), se puede tener una idea de cómo evoluciona la entrada a medida que el algoritmo corre. Con esto, y observando el código para entender a grandes rasgos lo que se quiere hacer, se puede determinar la complejidad de un algoritmo recursivo.

### Explicación Parte Practica
En el código proporcionado se dan dos metodologías para calcular la cantidad de caminos según las especificaciones de la tarea. Al correr el código, se generarán dos imágenes SVG. Estas corresponden a gráficos de tamaño de muestra y tiempo de ejecución para ambas metodologías. Los gráficos se generan mediante una iteración en la que se corre y mide el tiempo para distintos tamaños de grillas simétricas (por simplicidad se eligen de NxN). Dentro de la clase se crea un método que realiza la iteración y, dependiendo de la entrada, usa alguno de los dos métodos y almacena la cantidad de caminos para esa grilla en una lista (atributo de clase). De esta manera se obtienen la cantidad de caminos y el tiempo de ejecución para cada método en una grilla de un tamaño determinado.