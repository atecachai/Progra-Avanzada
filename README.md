# Progra-Avanzada
## Tarea 1
### Preguntas Teoricas:
1. 驴Que es un paradigma de programaci贸n?    
    Es una manera de resolver un problema en particular, usando herramientas de programaci贸n. Es decir, son los algoritmos y patrones que usamos para resolver problemas de programaci贸n. Se pueden identificar dos grandes paradigmas: (1). Programaci贸n Imperativa y (2). Programaci贸n Declarativa. El primero es el mas antiguo y se basa en una secuencia de instrucciones que van actualizando un programa. Dentro de este se encuentra la programaci贸n orientada a objetos. El segundo describe las cosas que se deben hacer las cosas, en vez de como hacerlas.
2. 驴En qu茅 se basa la programaci贸n orientada a objetos?
    En poder modelar el mundo real. Para esto crea objetos y les da formas de interactuar entre ellos en distintos estados. Esto se ve reflejado en un programa el cual esta compuesto por clases, sus atributos, y maneras de interactuar con otros objetos y el mismo, que son los metodos. Para este caso, la clase sirve de plantilla, y el objeto es una instancia de esta plantilla. A esta instancia se le pueden dar distintos atributos asi como metodos para interactuar con otras instancias.
3. 驴Cu谩l es la diferencia entre recursividad e iteraci贸n, y c贸mo se relaciona esto con la notaci贸n
big ?
    La iteraci贸n se refiere a repetir una accion o una operaci贸n un numero determinado de veces. La recursividad, en particular en programacion, se refiere a llevar a cabo una operacion pero llamandose o invocandose a si misma. Es decir, una funcion que se llama a si misma para resolver un problema. De manera general se puede entender que la recursividad busca generar subproblemas mas peque帽os para irlos solucionando hasta llegar a un caso base, mientras que la iteracion simplemente resuelve problemas cierta cantidad de veces. Cabe mencionar que la iteracion es un caso especial de recursividad. Relacionandolo con la nocion de big O, en ciertas situaciones se podria dar que un metodo es mejor que el otro en desmpe帽o, como por ejemplo los numeros de Fibonacci, donde la metodologia recursiva es O(2^n), y una iterativa (con memoria de resultados) es O(n). Con esto se quiere transmitir que dependiendo del problema, un metodo recursivo puede ser mas eficiente que uno iterativo, o viceversa, asi como que ambos puedan ser igual de eficientes.
4. Explicar la diferencia de rendimiento entre (1) y ()
    El O(1) se refiere a una complejidad constante o tiempo de ejecucion fijo, que no cambia a medida que aumente la entrada por ejemplo, a realizar una accion especifica, como darle dos numeros a una funcion y que los sume. Por el otro lado, O(n) va relacionado con un crecimiento lineal de la complejidad o tiempo de ejecuci贸n en relacion con la entrada, como iterar sobre una lista de n elementos. Esto signfica que para una entrada muy grande, O(1) tendria mejor rendimiento que para O(n), ya que se demoraria lo mismo para cualquier entrada, y por ende, menos que para O(n). En casos de entradas no tan altas esta diferencia podria ser despreciable. 
5. 驴C贸mo se calcula el orden en un programa que funciona por etapas?
    Se debe analizar cada etapa, y determinar que notacion le corresponde. Luego se pueden "sumar" estas, y finalmente la m谩s lenta o la menos eficiente es la que domina, respetando la jerarquia que existe entrada cada uno de los niveles. Por ejemplo, si se tiene un programa que resuelve una multiplicaci贸n y arroja un resultado, que luego se usa para iterar en una lista de n elementos, se parte con O(1), pero se termina con O(n), por lo que el orden seria O(n). Esto ya que la complejidad seria O(n)+O(1), pero O(n) es la complejidad dominante.
6. 驴C贸mo se puede determinar la complejidad temporal de un algoritmo recursivo?
    Se debe identificar la recurrencia, y ver si es afectada por valores externos, ademas de ver que se hace con la entrada al ser llamada. Viendo la complejidad temporal del factor externo y analizando que se realiza con la entrada (se duplica, resta, se le aplica log, etc), se puede dar una idea de como evoluciona la entrada a medida que el algoritmo corre. Con esto y observando el codigo para entender a grandes rasgos que se quiere hacerm, se puede determinar la complejidad de un algoritmo recursivo.