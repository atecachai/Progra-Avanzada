# Progra-Avanzada
## Tarea 1
### Preguntas Teoricas:
1. 쯈ue es un paradigma de programaci칩n?    
    Es una manera de resolver un problema en particular usando herramientas de programaci칩n. Es decir, son los algoritmos y patrones que utilizamos para resolver problemas de programaci칩n. Se pueden identificar dos grandes paradigmas: (1) Programaci칩n Imperativa y (2) Programaci칩n Declarativa. El primero es el m치s antiguo y se basa en una secuencia de instrucciones que van actualizando un programa. Dentro de este se encuentra la programaci칩n orientada a objetos. El segundo describe qu칠 se debe hacer, en lugar de c칩mo hacerlo.
2. 쮼n qu칠 se basa la programaci칩n orientada a objetos?
    Para poder modelar el mundo real, se crean objetos y se les da formas de interactuar entre ellos en distintos estados. Esto se ve reflejado en un programa que est치 compuesto por clases, sus atributos y las maneras de interactuar con otros objetos y consigo mismo, que son los m칠todos. En este caso, la clase sirve de plantilla, y el objeto es una instancia de dicha plantilla. A esta instancia se le pueden asignar distintos atributos, as칤 como m칠todos para interactuar con otras instancias.
3. 쮺u치l es la diferencia entre recursividad e iteraci칩n, y c칩mo se relaciona esto con la notaci칩n
big 洧녝?
    La iteraci칩n se refiere a repetir una acci칩n o una operaci칩n un n칰mero determinado de veces. La recursividad, en particular en programaci칩n, se refiere a llevar a cabo una operaci칩n invoc치ndose a s칤 misma. Es decir, una funci칩n que se llama a s칤 misma para resolver un problema. De manera general, se puede entender que la recursividad busca generar subproblemas m치s peque침os para ir solucion치ndolos hasta llegar a un caso base, mientras que la iteraci칩n simplemente resuelve problemas cierta cantidad de veces. Cabe mencionar que la iteraci칩n es un caso especial de recursividad. Relacion치ndolo con la noci칩n de Big O, en ciertas situaciones podr칤a darse que un m칠todo es mejor que el otro en desempe침o. Por ejemplo, en el c치lculo de los n칰meros de Fibonacci, la metodolog칤a recursiva es O(2^n), mientras que una iterativa (con memoria de resultados) es O(n). Con esto se quiere transmitir que, dependiendo del problema, un m칠todo recursivo puede ser m치s eficiente que uno iterativo, o viceversa, as칤 como que ambos puedan ser igual de eficientes.
4. Explicar la diferencia de rendimiento entre 洧녝(1) y 洧녝(洧녵)
    El O(1) se refiere a una complejidad constante o tiempo de ejecuci칩n fijo, que no cambia a medida que aumenta la entrada. Un ejemplo ser칤a realizar una acci칩n espec칤fica, como darle dos n칰meros a una funci칩n y que los sume. Por otro lado, O(n) est치 relacionado con un crecimiento lineal de la complejidad o tiempo de ejecuci칩n en relaci칩n con la entrada, como iterar sobre una lista de n elementos. Esto significa que, para una entrada muy grande, O(1) tendr칤a mejor rendimiento que O(n), ya que se demorar칤a lo mismo para cualquier entrada y, por ende, menos que O(n). En casos de entradas no tan grandes, esta diferencia podr칤a ser despreciable. 
5. 쮺칩mo se calcula el orden en un programa que funciona por etapas?
    Se debe analizar cada etapa y determinar qu칠 notaci칩n le corresponde. Luego, se pueden "sumar" estas, y finalmente la m치s lenta o la menos eficiente es la que domina, respetando la jerarqu칤a que existe entre cada uno de los niveles. Por ejemplo, si se tiene un programa que resuelve una multiplicaci칩n y arroja un resultado, que luego se usa para iterar en una lista de n elementos, se parte con O(1), pero se termina con O(n), por lo que el orden ser칤a O(n). Esto se debe a que la complejidad ser칤a O(n) + O(1), pero O(n) es la complejidad dominante.
6. 쮺칩mo se puede determinar la complejidad temporal de un algoritmo recursivo?
    Se debe identificar la recurrencia y ver si est치 afectada por valores externos, adem치s de analizar qu칠 se hace con la entrada al ser llamada. Viendo la complejidad temporal del factor externo y analizando qu칠 se realiza con la entrada (si se duplica, resta, se le aplica log, etc.), se puede tener una idea de c칩mo evoluciona la entrada a medida que el algoritmo corre. Con esto, y observando el c칩digo para entender a grandes rasgos lo que se quiere hacer, se puede determinar la complejidad de un algoritmo recursivo.

### Explicaci칩n Parte Practica
En el c칩digo proporcionado se dan dos metodolog칤as para calcular la cantidad de caminos seg칰n las especificaciones de la tarea. Al correr el c칩digo, se generar치n dos im치genes SVG. Estas corresponden a gr치ficos de tama침o de muestra y tiempo de ejecuci칩n para ambas metodolog칤as. Los gr치ficos se generan mediante una iteraci칩n en la que se corre y mide el tiempo para distintos tama침os de grillas sim칠tricas (por simplicidad se eligen de NxN). Dentro de la clase se crea un m칠todo que realiza la iteraci칩n y, dependiendo de la entrada, usa alguno de los dos m칠todos y almacena la cantidad de caminos para esa grilla en una lista (atributo de clase). De esta manera se obtienen la cantidad de caminos y el tiempo de ejecuci칩n para cada m칠todo en una grilla de un tama침o determinado.